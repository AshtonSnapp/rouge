use self:cmp:[PartialEquate]

# Range-related things

## An endpoint of a range of keys.
pub type Bound<T> is
	Unbounded
	Included is T
	Exlcuded is T
end

## Implemented by all Range types.
pub trait Bounded<T> is
	func start_bound(self) Bound<T>

	func stop_bound(self) Bound<T>

	func contains(self, Order T item) bool do
		return (if self.start_bound() is
			Bound:Unbounded then true
			Bound:Included(start) then item >= start
			Bound:Excluded(start) then item > start
		end) and (if self.stop_bound() is
			Bound:Unbounded then true
			Bound:Included(stop) then item <= stop
			Bound:Excluded(stop) then item < stop
		end)
	end
end

## A fully unbounded range. Created using `..`. It cannot be used as an iterator.
type RangeFull

impl Bounded<T> for RangeFull is
	func start_bound(self) Bound<T> do return Bound:Unbounded
	
	func stop_bound(self) Bound<T> do return Bound:Unbounded
end

## A range bounded inclusively below and exclusively below. `start..stop`
pub type Range<Idx> is
	pub Idx start
	pub Idx stop
end

impl Bounded<Idx> for Range<Idx> is
	func start_bound(self) Bound<Idx> do return Bound:Included(self.start)
	
	func stop_bound(self) Bound<Idx> do return Bound:Excluded(self.stop)
end

## A range bounded inclusively on both ends. `start..=stop`
pub type RangeInclusive<Idx> is
	pub Idx start
	pub Idx stop
end

impl Bounded<Idx> for RangeInclusive<Idx> is
	func start_bound(self) Bound<Idx> do return Bound:Included(self.start)
	
	func stop_bound(self) Bound<Idx> do return Bound:Included(self.stop)
end

## A range bounded only below. `start..`
type RangeFrom<Idx> is pub Idx start

impl Bounded<Idx> for RangeFrom<Idx> is
	func start_bound(self) Bound<Idx> do return Bound:Included(self.start)
	
	func stop_bound(self) Bound<Idx> do return Bound:Unbounded
end

## A range bounded only above. `..stop`
pub type RangeTo<Idx> is pub Idx stop

impl Bounded<Idx> for RangeTo<Idx> is
	func start_bound(self) Bound<Idx> do return Bound:Unbounded
	
	func stop_bound(self) Bound<Idx> do return Bound:Excluded(self.stop)
end

## A range inclusively bounded only above. `..=stop`
pub type RangeToInclusive<Idx> is pub Idx stop

impl Bounded<Idx> for RangeToInclusive<Idx> is
	func start_bound(self) Bound<Idx> do return Bound:Unbounded
	
	func stop_bound(self) Bound<Idx> do return Bound:Included(self.stop)
end

# Arithmetic and Bitwise Operation Traits

## The addition operator, `+`
pub trait Add<Rhs = Self, Out = Self> is
	func add(self, Rhs rhs) Out
end

## The addition assignment operator, `+=`
pub trait AddTo<Rhs = Self> is
	func add_to(mut self, Rhs rhs)
end

## The subtraction operator, `-`
pub trait Subtract<Rhs = Self, Out = Self> is
	func sub(self, Rhs rhs) Out
end

## The subtraction assignment operator, `-=`
pub trait SubtractFrom<Rhs = Self> is
	func sub_from(mut self, Rhs rhs)
end

## The multiplication operator, `*`
pub trait Multiply<Rhs = Self, Out = Self> is
	func mul(self, Rhs rhs) Out
end

## The multiplication assignment operator, `*=`
pub trait MultiplyBy<Rhs = Self> is
	func mul_by(mut self, Rhs rhs)
end

## The division operator, `/`
pub trait Divide<Rhs = Self, Out = Self> is
	func div(self, Rhs rhs) Out
end

## The division assignment operator, `/=`
pub trait DivideBy<Rhs = Self> is
	func div_by(mut self, Rhs rhs)
end

## The remainder operator, `%`
pub trait Remainder<Rhs = Self, Out = Self> is
	func rem(self, Rhs rhs) Out
end

## The remainder assignment operator, `%=`
pub trait RemainderOf<Rhs = Self> is
	func rem_of(mut self, Rhs rhs)
end

## The remainder comparison / divisible-by operator `%%`
pub trait DivisibleBy<Rhs = Self, PartialEquate<Rhs = Self> Out = Self>(Remainder<Rhs, PartialEquate<Rhs = Self> Out>) is
	const Out IS_FACTOR

	func divisible_by(self, Rhs rhs) bool do return self % rhs == IS_FACTOR
end

## The shift left operator, `<<`
pub trait ShiftLeft<Rhs = Self, Out = Self> is
	func shl(self, Rhs rhs) Out
end

## THe shift left assignment operator, `<<=`
pub trait ShiftLeftBy<Rhs = Self> is
	func shl_by(mut self, Rhs rhs)
end

## The shift right operator, `>>`
pub trait ShiftRight<Rhs = Self, Out = Self> is
	func shr(self, Rhs rhs) Out
end

## The shift right assignment operator, `>>=`
pub trait ShiftRightBy<Rhs = Self> is
	func shr_by(mut self, Rhs rhs)
end

## The bitwise and operator, `&`
pub trait BitAnd<Rhs = Self, Out = Self> is
	func bitand(self, Rhs rhs) Out
end

## The bitwise and assignment operator, `&=`
pub trait BitAndWith<Rhs = Self> is
	func bitand_with(mut self, Rhs rhs)
end

## The bitwise or operator, `|`
pub trait BitOr<Rhs = Self, Out = Self> is
	func bitor(self, Rhs rhs) Out
end

## The bitwise or assignment operator, `|=`
pub trait BitOrWith<Rhs = Self> is
	func bitor_with(mut self, Rhs rhs)
end

## The bitwise exclusive or operator, `^`
pub trait BitXor<Rhs = Self, Out = Self> is
	func bitxor(self, Rhs rhs) Out
end

## The bitwise exclusive or assignment operator, `^=`
pub trait BitXorWith<Rhs = Self> is
	func bitxor_with(mut self, Rhs rhs)
end

## The negation operator, `-`
pub trait Negate<Out = Self> is
	func neg(self) Out
end

## The logical and bitwise not operator, `!`
pub trait Not<Out = Self> is
	func not(self) Out
end

# Other operators

## The index operator, `[]`, in immutable contexts
pub trait Index<Idx, Out> is
	func index(self, Idx index) Out
end

## The index operator, `[]`, in mutable contexts
pub trait IndexMut(Index<Idx, Out>) is
	func index_mut(mut self, Idx index) mut Out
end

# Try related things

pub type ControlFlow<C = (), B> is
	Continue is C
	Break is B
end

pub trait FromResidual<R = <Self as Try>:Residual> is
	func from_residual(R residual) Self
end

pub trait Try(FromResidual<Self:Residual>) is
	type Output
	type Residual

	func from_output(Self:Output output) Self

	func branch(self) ControlFlow<Self:Output, Self:Residual>
end

## The bind operator, `>=>`
# A monad is a monoid in the category of endofunctors, what's the problem?
pub trait Bind is
	type Input
	type Output = Self:Input
	
	func bind(self, func(Self:Input) Self<Self:Output> f) Self<Self:Output>
end