use super::[
	Error
	Exn
	Result
]

use self::ops::Bind

pub type UnexpectedNone is str

pub type UnwrappedNone is ()

pub type Option<T> is
	None
	Some(T)

	pub func ok_or<E: Error>(self, e: E) -> Option<T> do if self is Some(t) then Result::Ok(t) else Result::Err(e)
	
	pub const func is_some(self) -> bool do if self is Some(_) then true else false

	pub func is_some_and(self, f: func(T) -> bool) -> bool do if self is Some(t) then f(t) else false

	pub func map<U>(self, f: func(T) -> U) -> Option<U> do if self is
		Some(t) then Some(f(t))
		None then none
	end

	pub func map_or<U>(self, default: U, f: func(T) -> U) -> U do if self is
		Some(t) then f(t)
		None then default
	end

	pub func map_or_else<U>(self, default: func() -> U, f: func(T) -> U) -> U do if self is
		Some(t) then f(t)
		None then default()
	end

	pub func and<U>(self, opt: Option<U>) -> Option<U> do if self is
		Some(_) then opt
		None then None
	end

	pub func and_then<U>(self, f: func(T) -> Option<U>) -> Option<U> do if self is
		Some(t) then f(t)
		None then None
	end

	pub func inspect(self, f: func(T)) -> Option<T> do
		if self is Some(t) then f(t)

		self
	end

	pub func expect(self, msg: str) -> T -< Exn<UnexpectedNone> do if self is
		Some(t) then t
		None then throw(UnexpectedNone msg)
	end
	
	pub func unwrap(self) -> T -< Exn<UnwrappedNone> do if self is
		Some(t) then t
		None then throw(UnwrappedNone)
	end

	pub func unwrap_or(self, default: T) -> T do if self is
		Some(t) then t
		None then default
	end

	pub func unwrap_or_else(self, f: func() -> T) -> T do if self is
		Some(t) then t
		None then f()
	end

	pub const func is_none(self) -> bool do if self is None then true else false

	pub func or<F>(self, opt: Option<T>) -> Option<T> do if self is
		Some(t) then Some(t)
		None then opt
	end

	pub func or_else<F>(self, f: func() -> Option<T>) -> Option<T> do if self is
		Some(t) then Some(t)
		None then f()
	end
end

impl Option<T: Default> is
	pub func unwrap_or_default(self) -> T do if self is
		Some(t) then t
		None then T::default()
	end
end

impl Bind<T> for Option<T> is
	func bind(self, f: func(T) -> T) -> Option<T> = map<T>(self, f)
end

impl Bind<T, U> for Option<T> is
	func bind(self, f: func(T) -> U) -> Option<U> = map<U>(self, f)
end