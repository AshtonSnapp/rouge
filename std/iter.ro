use self::[
	cmp::[
		PartialEq
		Eq
		PartialOrd
		Ord
		Ordering
	]
	ops::[
		Add
		Mul
	]
]

## An effect which allows a function to continuously yield values.
pub effect Yield<T> is
	## Yields some value to the outside of the function.
	func yield(val: T)
end

## A trait for types that can be iterated over.
pub trait Iter<T> is
	## The iteration function. This is automatically called by for loops, which desugar to scoped handlers for `Yield::yield`.
	func iter(self) -< Yield<T>, E

	## Tests if every element of the iterable matches a predicate.
	##
	## `all()` takes a closure that returns `true` or `false`. It applies this closure to each element of the iterable,
	## and if they all return `true`, then so does `all()`. If any of them return `false`, it returns `false`.
	##
	## `all()` is short-circuiting; in other words, it will stop processing as soon as it finds a `false`, given that
	## no matter what else happens, the result will also be `false`.
	##
	## An empty iterable returns `true`.
	##
	## # Example
	## ```
	## a := [1, 2, 3]
	##
	## assert!(a.all((x) do x > 0))
	##
	## assert!(not a.all((x) do x > 2))
	## ```
	func all(self, f: Func(T) -> bool) -> bool do
		for item in self do if not f(item) then return false

		true
	end

	## Tests if any element of the iterable matches a predicate.
	##
	## `any()` takes a closure that returns `true` or `false`. It applies this closure to each element of the iterable,
	## and if any of them return `true`, then so does `any()`. If they all return `false`, it returns `false`.
	##
	## `any()` is short-circuiting; in other words, it will stop processing as soon as it finds a `true`, given that no
	## matter what else happens, the result will also be `true`.
	##
	## An empty iterable returns `false`.
	##
	## # Example
	## ```
	## a := [1, 2, 3]
	## 
	## assert!(a.any((x) do x > 0))
	##
	## assert!(not a.any((x) do x > 5))
	## ```
	func any(self, f: Func(T) -> bool) -> bool do
		for item in self do if f(item) then return true

		false
	end

	## Takes two iterables and creates a new iterable over both in sequence.
	##
	## `chain()` will return a new iterable which will first iterate over values from the first iterable and then over
	## values of the second iterable.
	##
	## In other words, it links two iterables together, in a chain.
	##
	## `once` is commonly used to adapt a single value into a chain of other kinds of iteration.
	func chain<I: Iter<T>>(self, other: I) -> Chain<Self, I> do (self, other)

	## Repeats an iterable endlessly.
	func cycle(self) -> Cycle<Self> do (self)

	## Creates an iterable which yields the current iteration count as well as the next value.
	##
	## The iterable returned yields pairs (i, val), where `i` is the current index of iteration and
	## `val` is the value returned by the iterable.
	func enumerate(self) -> Enumerate<Self> do (self)

	## Creates an iterable which uses a closure to determine if an element should be yielded.
	##
	## Given an element the closure must return `true` or `false`.
	## The returned iterable will yield only the elements for which the closure returns `true`.
	func filter<F: Func(T) -> bool>(self, f: F) -> Filter<Self, F> do (self, f)

	## Creates an iterable that both filters and maps.
	##
	## The returned iterable yields only the `value`s for which the supplied closure returns `Some(value)`.
	##
	## `filter_map` can be used to make chains of `filter` and `map` more concise.
	func filter_map<U, F: Func(T) -> Option<U>>(self, f: F) -> FilterMap<Self, F> do (self, f)

	## Searches for an element of an iterable that matches a predicate.
	##
	## `find()` takes a closure that returns `true` or `false`. It applies 
	func find(self, predicate: Func(T) -> bool) -> Option<T> do
		for item in self do if predicate(item) then return Some(item)

		None
	end

	## Applies function to the elements of the iterator and returns the first non-none result.
	func find_map<U>(self, f: Func(T) -> Option<U>) -> Option<U> do
		for item in self do if f(item) matches Some(val) then return Some(val)

		None
	end

	## Creates an ierable that works like map, but flattens nested structure.
	##
	## The `map` adapter is very useful, but only when the closure argument produces values.
	## If it produces an iterable instead, there's an extra layer of indirection.
	## `flat_map()` will remove this extra layer on its own.
	##
	## You can think of `flat_map(f)` as the semantic equivalent of `map`ping,
	## and then `flatten`ing as in `map(f).flatten()`.
	##
	## Another way of thinking about `flat_map()`: `map`'s closure returns one item for each element,
	## and `flat_map()`'s closure returns an iterable for each element.
	func flat_map<U, F: Func(T) -> U>(self, f: F) -> FlatMap<Self, U, F> do (self, f)

	## Creates an iterable that flattens nested structure.
	##
	## This is useful when you have an iterable of iterables and you want to remove one layer of indirection.
	func flatten(self) -> Flatten<Self> do (self)

	## Folds every element into an accumulator by applying an operation, returning the final result.
	##
	## `fold()` takes two arguments: an initial value, and a closure with two arguments:
	## an `accumulator`, and an element.
	## The closure returns the value that the accumulator should have for the next iteration.
	##
	## The initial value is the value that the accumulator will have on the first call.
	##
	## After applying this closure to every element of the iterable, `fold()` returns the accumulator.
	##
	## This operation is sometimes called `reduce` or `inject`.
	##
	## Folding is useful whenever you have a collection of something, and want to produce a single value from it.
	##
	## Note: `fold()`, and similar methods that traverse the entire iterable, might not terminate for infnite iterables,
	## even on traits for which a result is determinable in finite time.
	##
	## Note: `reduce()` can be used to use the first element as the initial value,
	## if the accumulator type and item type are the same.
	##
	## Note: `fold()` combines elements in a _left-associative_ fashion. For associative operators like `+`,
	## the order the elements are combined in is not important, but for non-associative operators like `-` the order
	## will affect the final result.
	func fold<U>(self, init: U, f: Func(U, T) -> U) -> U do
		mut acc := init

		for item in self do acc = f(acc, item)

		acc
	end

	func for_each(self, f: Func(T)) do for item in self do f(item)

	func inspect<F: Func(T)>(self, f: F) -> Inspect<Self, F> do (self, f)

	func intersperse<I: Iter<T>>(self, separator: I) -> Intersperse<Self, I> do (self, separator)

	func len(self) -> nat do
		mut count := 0

		for _ in self do count += 1

		count
	end

	func map<U, F: Func(T) -> U>(self, f: F) -> Map<Self, F> do (self, f)

	func map_while<U, F: Func(T) -> Option<U>>(self, f: F) -> MapWhile<Self, F> do (self, f)

	func max<T: Ord>(self) -> Option<T> do
		mut ret := None

		for item in self do if ret matches
			None then ret = Some(item)
			Some(max) then if item >= max then ret = Some(item)
		end

		ret
	end

	func max_by<F: Func(T, T) -> Ordering>(self, compare: F) -> Option<T> do
		mut ret := None

		for item in self do if ret matches
			None then ret = Some(item)
			Some(max) then if compare(max, item) matches Ordering::Greater | Ordering::Equal then ret = Some(item)
		end

		ret
	end

	func max_by_key<U: Ord, Func(T) -> U>(self, f: F) -> Option<T> do	
		(_, x) = self.map((x) do (f(x), x)).max_by(((x_p, _), (y_p, _)) do x_p.cmp(y_p))?
		Some(x)
	end

	func max_of<I: Iter<T: Ord>>(self, other: I) -> MaxOf<Self, I> do (self, other)

	func max_of_by<I: Iter<T>, F: Func(T, T) -> Ordering>(self, other: I, compare: F) -> MaxOfBy<Self, I, F> do (self, other, compare)

	func min<T: Ord>(self) -> Option<T> do
		mut ret := None

		for item in self do if ret matches
			None then ret = Some(item)
			Some(min) then if item <= min then ret = Some(item)
		end

		ret
	end

	func min_by<F: Func(T, T) -> Ordering>(self, compare: F) -> Option<T> do
		mut ret := None

		for item in self do if ret matches
			None then ret = Some(item)
			Some(min) then if compare(min, item) matches Ordering::Less | Ordering::Equal then ret = Some(item)
		end

		ret
	end

	func min_by_key<U: Ord, Func(T) -> U>(self, f: F) -> Option<T> do	
		(_, x) = self.map((x) do (f(x), x)).min_by(((x_p, _), (y_p, _)) do x_p.cmp(y_p))?
		Some(x)
	end

	func min_of<I: Iter<T: Ord>>(self, other: I) -> MinOf<Self, I> do (self, other)

	func min_of_by<I: Iter<T>, F: Func(T, T) -> Ordering>(self, other: I, compare: F) -> MinOfBy<Self, I, F> do (self, other, compare)

	func product<T: Mul>(self) -> Option<T> do self.reduce((a, b) do a * b)

	func reduce(self, f: Func(T, T) -> T) -> Option<T> do
		mut ret := None

		for item in self do if acc matches
			None then ret = Some(item)
			Some(acc) then ret = Some(f(acc, item))
		end

		ret
	end

	func scan<U, F: Func(mut St, T) -> Option<U>>(self, init: U, f: F) -> Scan<Self, U, F> do (self, init, f)

	func skip(self, n: nat) -> Skip<Self> do (self, n)

	func skip_while<P: Func(T) -> bool>(self, predicate: P) -> SkipWhile<Self, P> do (self, predicate)

	func step_by(self, step: nat) -> StepBy<Self> do (self, step)

	func sum<T: Add>(self) -> Option<T> do self.reduce((a, b) do a + b)

	func take(self, n: nat) -> Take<Self> do (self, n)

	func take_while<P: Func(T) -> bool>(self, predicate: P) -> TakeWhile<Self, P> do (self, predicate)

	func unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where
		FromA: Default + Extend<A>
		FromB: Default + Extend<B>
		T = (A, B)
	do
	end

	func zip<I: Iter<U>>(self, other: I) -> Zip<Self, I> do (self, other)
end

## A trait for types that can be mutably iterated over.
pub trait IterMut<M = mut T>: Iter<T> is
	## The mutable iteration function. This is automatically called by for loops with mutable items, which desugar to scoped handlers for `Yield::yield`.
	func iter_mut(mut self) -< Yield<M>, E
end