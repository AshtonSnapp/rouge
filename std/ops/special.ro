## Custom code within the destructor.
##
## When a value is no longer needed, a destructor will be ran on that value.
## The most common way that a value is no longer needed is when it goes out of scope.
## Destructors may still run in other circumstances.
##
## This destructor consists of two components:
##  - A call to `Drop::drop` for that value, if this special `Drop` trait is implemented
## for its type.
##  - The automatically generated "drop glue" which recursilvely calls the destructors
## for all the fields of this value.
##
## As we automatically call the destructors of all contained fields, you don't have to
## implement Drop in most cases. But there are some cases where it is useful, for example
## for types which directly manage a resource. That resource may be in memory, it may be
## a file descriptor, it may be a network socket. Once a value of that type is no longer
## going to be used, it should "clean up" the resource by freeing the memory or closing
## the file or socket. This is the job of the destructor, and therefore the job of
## `Drop::drop`.
pub trait Drop is
    ## Executes the destructor for this type.
    ##
    ## This method is called implicitly when the value goes out of scope, and cannot be
    ## called explicitly (this is a compiler error). When this method has been called,
    ## `self` has not yet been deallocated. That only happens after the method is over.
    ## If this wasn't the case, `self` would be a dangling reference.
    func drop(mut self) -< `E: !Exn
end