use std:ops:Bind

pub type Option<T> is
	None
	Some is T

	pub func is_some(self) bool do
		return if self is
			None then false
			Some _ then true
		end
	end

	pub func is_some_and(self, func(T) bool f) bool do
		return if self is
			None then false
			Some t then f(t)
		end
	end

	pub func is_none(self) bool do
		return if self is
			None then true
			Some _ then false
		end
	end
end

impl Bind for Option<T> is
	type Input = T
	type Output = T

	func bind(self, func(T) Option<T> f) Option<T> do
		return if self is
			Some t then f(t)
			None then None
		end
	end
end

impl<U> Bind for Option<T> is
	type Input = T
	type Output = U

	func bind(self, func(T) Option<U> f) Option<U> do
		return if self is
			Some t then f(t)
			None then None
		end
	end
end

pub type Result<T, E> is
	Ok is T
	Err is E

	pub func is_ok(self) bool do
		return if self is
			Ok _ then true
			Err _ then false
		end
	end

	pub func is_ok_and(self, func(T) bool f) bool do
		return if self is
			Ok t then f(t)
			Err _ then false
		end
	end

	pub func is_err(self) bool do
		return if self is
			Ok _ then false
			Err _ then true
		end
	end

	pub func is_err_and(self, func(E) bool f) bool do
		return if self is
			Ok _ then false
			Err e then f(e)
		end
	end
end

impl Bind for Result<T, E> is
	type Input = T
	type Output = T

	func bind(self, func(T) Result<T, E> f) Result<T, E> do
		return if self is
			Ok t then f(t)
			Err e then Err e
		end
	end
end

impl<U> Bind for Result<T, E> is
	type Input = T
	type Output = U

	func bind(self, func(T) Result<U, E> f) Result<U, E> do
		return if self is
			Ok t then f(t)
			Err e then Err e
		end
	end
end